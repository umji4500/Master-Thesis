# File: sso_pass_solver.py

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Constants (SI units)
MU = 3.986004418e14       # Earth's gravitational parameter, m^3/s^2
R_EARTH = 6371e3          # Earth radius, m
J2 = 1.08263e-3           # Earth‚Äôs J2 perturbation coefficient
OMEGA_DOT_SUN = 1.99106e-7 # Desired RAAN drift for SSO, rad/s
OMEGA_EARTH = 7.2921159e-5  # Earth rotation rate, rad/s

# Epoch and simulation time
EPOCH = datetime(2025, 3, 20, 0, 0, 0)
TIME_STEP = 10            # Time resolution, seconds
SIM_DURATION = 24 * 3600  # Total simulation duration, seconds (1 day)

# Ground target (Incheon Airport)
TARGET_LAT = np.radians(37.4602)
TARGET_LON = np.radians(126.4407)

# Minimum elevation for visibility check (radians)
MIN_ELEVATION = np.radians(20)

def compute_elevation(lat_sat, lon_sat, lat_target, lon_target, sat_alt):
    x_sat = (R_EARTH + sat_alt) * np.cos(lat_sat) * np.cos(lon_sat)
    y_sat = (R_EARTH + sat_alt) * np.cos(lat_sat) * np.sin(lon_sat)
    z_sat = (R_EARTH + sat_alt) * np.sin(lat_sat)

    x_tgt = R_EARTH * np.cos(lat_target) * np.cos(lon_target)
    y_tgt = R_EARTH * np.cos(lat_target) * np.sin(lon_target)
    z_tgt = R_EARTH * np.sin(lat_target)

    dx = x_sat - x_tgt
    dy = y_sat - y_tgt
    dz = z_sat - z_tgt
    r_vec = np.array([dx, dy, dz])
    r_mag = np.linalg.norm(r_vec)

    tgt_vec = np.array([x_tgt, y_tgt, z_tgt])
    tgt_unit = tgt_vec / np.linalg.norm(tgt_vec)
    cos_theta = np.dot(r_vec, tgt_unit) / r_mag
    return np.arcsin(cos_theta)  # returns radians


def orbital_period(a):
    return 2 * np.pi * np.sqrt(a**3 / MU)

def inclination_for_sso(a):
    e = 0
    n = np.sqrt(MU / a**3)
    term = (-2 * OMEGA_DOT_SUN * a**2) / (3 * J2 * R_EARTH**2 * n)
    term = np.clip(term, -1.0, 1.0)
    return np.arccos(term)

def solve_kepler(M, e, tol=1e-8):
    E = M if e < 0.8 else np.pi
    for _ in range(100):
        f = E - e * np.sin(E) - M
        f_prime = 1 - e * np.cos(E)
        E -= f / f_prime
        if abs(f) < tol:
            break
    return E

def propagate_orbit(a, e, inc, RAAN, AOP, M0, duration=SIM_DURATION, dt=TIME_STEP):
    n = np.sqrt(MU / a**3)
    steps = int(duration / dt)
    positions = []
    times = []

    # Precession rates
    p = a * (1 - e**2)
    Omega_dot = -1.5 * J2 * (R_EARTH**2) * n * np.cos(inc) / (p**2)
    omega_dot = 0.75 * J2 * (R_EARTH**2) * n * (5 * np.cos(inc)**2 - 1) / (p**2)
    M_dot = n + 0.75 * J2 * (R_EARTH**2) * n * (3 * np.cos(inc)**2 - 1) / (p**2)

    for step in range(steps):
        t = step * dt
        RAAN_t = RAAN + Omega_dot * t
        AOP_t = AOP + omega_dot * t
        M_t = M0 + M_dot * t
        E = solve_kepler(M_t % (2 * np.pi), e)
        TA = 2 * np.arctan2(np.sqrt(1 + e) * np.sin(E / 2),
                           np.sqrt(1 - e) * np.cos(E / 2))

        r_mag = a * (1 - e * np.cos(E))
        r_pf = np.array([r_mag * np.cos(TA), r_mag * np.sin(TA), 0])

        cos_RAAN, sin_RAAN = np.cos(RAAN_t), np.sin(RAAN_t)
        cos_inc, sin_inc = np.cos(inc), np.sin(inc)
        cos_AOP, sin_AOP = np.cos(AOP_t), np.sin(AOP_t)

        R1 = np.array([[cos_RAAN, -sin_RAAN, 0], [sin_RAAN, cos_RAAN, 0], [0, 0, 1]])
        R2 = np.array([[1, 0, 0], [0, cos_inc, -sin_inc], [0, sin_inc, cos_inc]])
        R3 = np.array([[cos_AOP, -sin_AOP, 0], [sin_AOP, cos_AOP, 0], [0, 0, 1]])
        r_eci = R1 @ R2 @ R3 @ r_pf

        gst = OMEGA_EARTH * t
        cos_gst, sin_gst = np.cos(gst), np.sin(gst)
        x = r_eci[0] * cos_gst + r_eci[1] * sin_gst
        y = -r_eci[0] * sin_gst + r_eci[1] * cos_gst
        z = r_eci[2]
        positions.append((x, y, z))
        times.append(EPOCH + timedelta(seconds=int(t)))

    return np.array(positions), np.array(times)

def eci_to_latlon(r_vec):
    x, y, z = r_vec
    r = np.linalg.norm(r_vec)
    lat = np.arcsin(z / r)
    lon = np.arctan2(y, x)
    return lat, lon

def is_visible(lat_sat, lon_sat, lat_target, lon_target, sat_alt):
    return compute_elevation(lat_sat, lon_sat, lat_target, lon_target, sat_alt) >= MIN_ELEVATION


def find_passes(a, e, inc, RAAN, AOP, M0, plot=False):
    pos, times = propagate_orbit(a, e, inc, RAAN, AOP, M0)
    pass_durations = []
    current_pass = []
    all_pass_times = []
    latitudes = []
    longitudes = []

    for r_vec, t in zip(pos, times):
        lat, lon = eci_to_latlon(r_vec)
        latitudes.append(np.degrees(lat))
        longitudes.append(np.degrees(lon))
        if is_visible(lat, lon, TARGET_LAT, TARGET_LON, np.linalg.norm(r_vec) - R_EARTH):
            current_pass.append(t)
        else:
            if current_pass:
                duration = (current_pass[-1] - current_pass[0]).total_seconds() + TIME_STEP
                pass_durations.append(duration)
                all_pass_times.append((current_pass[0], current_pass[-1]))
                current_pass = []

    for i, (start, end) in enumerate(all_pass_times):
        print(f"Pass {i+1}: {start} to {end}, duration = {(end - start).total_seconds() + TIME_STEP} seconds")

    if plot:
        # üåç Ground track plot
        plt.figure(figsize=(10, 5))
        plt.plot(longitudes, latitudes, label='Satellite Ground Track')
        plt.scatter(np.degrees(TARGET_LON), np.degrees(TARGET_LAT), color='red', label='Incheon Airport')
        plt.xlabel('Longitude (deg)')
        plt.ylabel('Latitude (deg)')
        plt.title('Ground Track of Satellite over 24 Hours')
        plt.grid(True)
        plt.legend()
        plt.show()

        # üìà Elevation angle plot
        if all_pass_times:
            best_start, best_end = max(all_pass_times, key=lambda x: (x[1] - x[0]).total_seconds())
            elev_angles = []
            elev_times = []

            for r_vec, t in zip(pos, times):
                if best_start <= t <= best_end:
                    lat, lon = eci_to_latlon(r_vec)
                    sat_alt = np.linalg.norm(r_vec) - R_EARTH
                    elevation = compute_elevation(lat, lon, TARGET_LAT, TARGET_LON, sat_alt)

                    if elevation >= MIN_ELEVATION:
                        elev_angles.append(np.degrees(elevation))
                        elev_times.append(t)

            if elev_angles:
                plt.figure(figsize=(10, 4))
                plt.plot(elev_times, elev_angles, label='Elevation Angle')
                plt.axhline(np.degrees(MIN_ELEVATION), color='green', linestyle='--', label='Elevation Threshold')
                plt.xlabel("UTC Time")
                plt.ylabel("Elevation Angle (deg)")
                plt.title("Elevation Angle over Best Visibility Pass (Above Threshold)")
                plt.grid(True)
                plt.legend()
                plt.show()

    max_pass = max(pass_durations, default=0)
    total_visible = sum(pass_durations)
    num_passes = len(pass_durations)
    return max_pass, total_visible, num_passes


def sweep_altitudes():
    alts = np.arange(660e3, 689e3 + 1, 5e3)
    best_alt = None
    best_duration = 0
    for alt in alts:
        a = R_EARTH + alt
        e = 0.001
        inc = inclination_for_sso(a)
        RAAN, AOP, M0 = 0.0, 0.0, 0.0
        pass_durs = find_passes(a, e, inc, RAAN, AOP, M0, plot=False)
        max_pass = max(pass_durs, default=0)
        if max_pass > best_duration:
            best_duration = max_pass
            best_alt = alt

    if best_alt:
        print(f"‚úÖ Best Altitude: {best_alt / 1e3:.1f} km")
        print(f"üïì Longest Pass Duration: {best_duration:.1f} seconds")
        print(f"üì° Visibility Elevation Threshold: {np.degrees(MIN_ELEVATION):.1f}¬∞")

        # Re-run with best altitude for visualization
        a = R_EARTH + best_alt
        e = 0.001
        inc = inclination_for_sso(a)
        find_passes(a, e, inc, 0.0, 0.0, 0.0, plot=True)
    # ‚úÖ Return values here
        return best_alt, best_duration

    else:
        print("‚ùå No valid altitude found with visible passes.")
        return None, 0  # Optional: handles case where nothing was found




        

# Optimizing KOMPSAT-Style SSO: Best M0 for Max Pass Duration, Visibility, and Revisit Count

if __name__ == "__main__":
    # KOMPSAT-style fixed SSO baseline case
    a = R_EARTH + 685e3
    inc = inclination_for_sso(a)
    e = 0.001
    RAAN = 0.0
    AOP = 0.0

    # Sweep M0
    results = []
    for M0_deg in range(0, 360, 10):
        M0 = np.radians(M0_deg)
        max_pass, total_visible, num_passes = find_passes(a, e, inc, RAAN, AOP, M0, plot=False)
        results.append({
            "M0": M0,
            "max_pass": max_pass,
            "total_visible": total_visible,
            "num_passes": num_passes
        })

    # Find best by each metric
    best_by_max_pass = max(results, key=lambda x: x["max_pass"])
    best_by_total_vis = max(results, key=lambda x: x["total_visible"])
    best_by_num_pass = max(results, key=lambda x: x["num_passes"])

    print("\nüéØ Best SSO Configurations by Selection Criteria:")

    # Max Single Pass
    print("\nüîç SSO Config (1Ô∏è‚É£ Max Single-Pass Duration)")
    print(f"    Altitude      : 685.0 km")
    print(f"    Inclination   : {np.degrees(inc):.4f}¬∞")
    print(f"    RAAN          : {RAAN:.1f}¬∞")
    print(f"    AOP           : {AOP:.1f}¬∞")
    print(f"‚úÖ  Best M0        : {np.degrees(best_by_max_pass['M0']):.1f}¬∞")
    print(f"‚è±Ô∏è  Max Pass Duration : {best_by_max_pass['max_pass']:.1f} seconds")

    # Total Visibility
    print("\nüîç SSO Config (2Ô∏è‚É£ Max Total Visibility)")
    print(f"    Altitude      : 685.0 km")
    print(f"    Inclination   : {np.degrees(inc):.4f}¬∞")
    print(f"    RAAN          : {RAAN:.1f}¬∞")
    print(f"    AOP           : {AOP:.1f}¬∞")
    print(f"‚úÖ  Best M0        : {np.degrees(best_by_total_vis['M0']):.1f}¬∞")
    print(f"üïì  Total Visibility Time : {best_by_total_vis['total_visible']:.1f} seconds")

    # Number of Passes
    print("\nüîç SSO Config (3Ô∏è‚É£ Max Number of Passes)")
    print(f"    Altitude      : 685.0 km")
    print(f"    Inclination   : {np.degrees(inc):.4f}¬∞")
    print(f"    RAAN          : {RAAN:.1f}¬∞")
    print(f"    AOP           : {AOP:.1f}¬∞")
    print(f"‚úÖ  Best M0        : {np.degrees(best_by_num_pass['M0']):.1f}¬∞")
    print(f"üîÅ  Number of Passes : {best_by_num_pass['num_passes']}")

    # Save result for max single-pass duration (you can change this to any best)
    save_sso_result(
        filename="sso_baseline_result.csv",
        altitude_km=685,
        inclination_rad=inc,
        best_M0_rad=best_by_max_pass["M0"],
        max_duration_s=best_by_max_pass["max_pass"],
        epoch=EPOCH
    )

    # Plot the best max-pass-duration case
    find_passes(a, e, inc, RAAN, AOP, best_by_max_pass["M0"], plot=True)
    find_passes(a, e, inc, RAAN, AOP, best_by_total_vis["M0"], plot=True)





import os

# Check current working directory
print("üìÇ Current directory:", os.getcwd())

# List all files in the current directory
print("üìÑ Files:", os.listdir())




from google.colab import files
files.download("sso_baseline_result.csv")




# Output: UTC timestamp for a given M0 (e.g., 0¬∞, 150¬∞, etc.)

from datetime import datetime, timedelta
import numpy as np

# Constants
MU = 3.986004418e14       # Earth's gravitational parameter (m^3/s^2)
R_EARTH = 6371e3          # Earth radius (m)

# KOMPSAT SSO parameters
altitude = 685e3          # 685 km
a = R_EARTH + altitude    # semi-major axis in meters
epoch = datetime(2025, 3, 20, 0, 0, 0)  # reference epoch

def mean_motion(a):
    """Calculate mean motion in rad/s"""
    return np.sqrt(MU / a**3)

def m0_to_utc_offset(m0_deg, a, epoch):
    """Convert mean anomaly (degrees) to UTC time"""
    n = mean_motion(a)  # rad/s
    m0_rad = np.radians(m0_deg)
    delta_t = m0_rad / n  # seconds
    utc_time = epoch + timedelta(seconds=delta_t)
    return utc_time

# Example: convert M0 = 150¬∞ to UTC time
m0_deg = 0
utc_time = m0_to_utc_offset(m0_deg, a, epoch)
print(f"‚úÖ M0 = {m0_deg}¬∞ corresponds to UTC time: {utc_time.strftime('%Y-%m-%d %H:%M:%S')}")
