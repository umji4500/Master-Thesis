# File: sso_pass_solver.py

import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Constants (SI units)
MU = 3.986004418e14       # Earth's gravitational parameter, m^3/s^2
R_EARTH = 6371e3          # Earth radius, m
J2 = 1.08263e-3           # Earth‚Äôs J2 perturbation coefficient
OMEGA_DOT_SUN = 1.99106e-7 # Desired RAAN drift for SSO, rad/s
OMEGA_EARTH = 7.2921159e-5  # Earth rotation rate, rad/s

# Epoch and simulation time
EPOCH = datetime(2025, 3, 20, 0, 0, 0)
TIME_STEP = 10            # Time resolution, seconds
SIM_DURATION = 24 * 3600  # Total simulation duration, seconds (1 day)

# Ground target (Incheon Airport)
TARGET_LAT = np.radians(37.4602)
TARGET_LON = np.radians(126.4407)

# Minimum elevation for visibility check (radians)
MIN_ELEVATION = np.radians(20)

def compute_elevation(lat_sat, lon_sat, lat_target, lon_target, sat_alt):
    x_sat = (R_EARTH + sat_alt) * np.cos(lat_sat) * np.cos(lon_sat)
    y_sat = (R_EARTH + sat_alt) * np.cos(lat_sat) * np.sin(lon_sat)
    z_sat = (R_EARTH + sat_alt) * np.sin(lat_sat)

    x_tgt = R_EARTH * np.cos(lat_target) * np.cos(lon_target)
    y_tgt = R_EARTH * np.cos(lat_target) * np.sin(lon_target)
    z_tgt = R_EARTH * np.sin(lat_target)

    dx = x_sat - x_tgt
    dy = y_sat - y_tgt
    dz = z_sat - z_tgt
    r_vec = np.array([dx, dy, dz])
    r_mag = np.linalg.norm(r_vec)

    tgt_vec = np.array([x_tgt, y_tgt, z_tgt])
    tgt_unit = tgt_vec / np.linalg.norm(tgt_vec)
    cos_theta = np.dot(r_vec, tgt_unit) / r_mag
    return np.arcsin(cos_theta)  # returns radians


def orbital_period(a):
    return 2 * np.pi * np.sqrt(a**3 / MU)

def inclination_for_sso(a):
    e = 0
    n = np.sqrt(MU / a**3)
    term = (-2 * OMEGA_DOT_SUN * a**2) / (3 * J2 * R_EARTH**2 * n)
    term = np.clip(term, -1.0, 1.0)
    return np.arccos(term)

def solve_kepler(M, e, tol=1e-8):
    E = M if e < 0.8 else np.pi
    for _ in range(100):
        f = E - e * np.sin(E) - M
        f_prime = 1 - e * np.cos(E)
        E -= f / f_prime
        if abs(f) < tol:
            break
    return E

def propagate_orbit(a, e, inc, RAAN, AOP, M0, duration=SIM_DURATION, dt=TIME_STEP):
    n = np.sqrt(MU / a**3)
    steps = int(duration / dt)
    positions = []
    times = []

    # Precession rates
    p = a * (1 - e**2)
    Omega_dot = -1.5 * J2 * (R_EARTH**2) * n * np.cos(inc) / (p**2)
    omega_dot = 0.75 * J2 * (R_EARTH**2) * n * (5 * np.cos(inc)**2 - 1) / (p**2)
    M_dot = n + 0.75 * J2 * (R_EARTH**2) * n * (3 * np.cos(inc)**2 - 1) / (p**2)

    for step in range(steps):
        t = step * dt
        RAAN_t = RAAN + Omega_dot * t
        AOP_t = AOP + omega_dot * t
        M_t = M0 + M_dot * t
        E = solve_kepler(M_t % (2 * np.pi), e)
        TA = 2 * np.arctan2(np.sqrt(1 + e) * np.sin(E / 2),
                           np.sqrt(1 - e) * np.cos(E / 2))

        r_mag = a * (1 - e * np.cos(E))
        r_pf = np.array([r_mag * np.cos(TA), r_mag * np.sin(TA), 0])

        cos_RAAN, sin_RAAN = np.cos(RAAN_t), np.sin(RAAN_t)
        cos_inc, sin_inc = np.cos(inc), np.sin(inc)
        cos_AOP, sin_AOP = np.cos(AOP_t), np.sin(AOP_t)

        R1 = np.array([[cos_RAAN, -sin_RAAN, 0], [sin_RAAN, cos_RAAN, 0], [0, 0, 1]])
        R2 = np.array([[1, 0, 0], [0, cos_inc, -sin_inc], [0, sin_inc, cos_inc]])
        R3 = np.array([[cos_AOP, -sin_AOP, 0], [sin_AOP, cos_AOP, 0], [0, 0, 1]])
        r_eci = R1 @ R2 @ R3 @ r_pf

        gst = OMEGA_EARTH * t
        cos_gst, sin_gst = np.cos(gst), np.sin(gst)
        x = r_eci[0] * cos_gst + r_eci[1] * sin_gst
        y = -r_eci[0] * sin_gst + r_eci[1] * cos_gst
        z = r_eci[2]
        positions.append((x, y, z))
        times.append(EPOCH + timedelta(seconds=int(t)))

    return np.array(positions), np.array(times)

def eci_to_latlon(r_vec):
    x, y, z = r_vec
    r = np.linalg.norm(r_vec)
    lat = np.arcsin(z / r)
    lon = np.arctan2(y, x)
    return lat, lon

def is_visible(lat_sat, lon_sat, lat_target, lon_target, sat_alt):
    return compute_elevation(lat_sat, lon_sat, lat_target, lon_target, sat_alt) >= MIN_ELEVATION


def find_passes(a, e, inc, RAAN, AOP, M0, plot=False):
    pos, times = propagate_orbit(a, e, inc, RAAN, AOP, M0)
    pass_durations = []
    current_pass = []
    all_pass_times = []
    latitudes = []
    longitudes = []

    for r_vec, t in zip(pos, times):
        lat, lon = eci_to_latlon(r_vec)
        latitudes.append(np.degrees(lat))
        longitudes.append(np.degrees(lon))
        if is_visible(lat, lon, TARGET_LAT, TARGET_LON, np.linalg.norm(r_vec) - R_EARTH):
            current_pass.append(t)
        else:
            if current_pass:
                duration = (current_pass[-1] - current_pass[0]).total_seconds() + TIME_STEP
                pass_durations.append(duration)
                all_pass_times.append((current_pass[0], current_pass[-1]))
                current_pass = []

    for i, (start, end) in enumerate(all_pass_times):
        print(f"Pass {i+1}: {start} to {end}, duration = {(end - start).total_seconds() + TIME_STEP} seconds")

    if plot:
        # üåç Ground track plot
        plt.figure(figsize=(10, 5))
        plt.plot(longitudes, latitudes, label='Satellite Ground Track')
        plt.scatter(np.degrees(TARGET_LON), np.degrees(TARGET_LAT), color='red', label='Incheon Airport')
        plt.xlabel('Longitude (deg)')
        plt.ylabel('Latitude (deg)')
        plt.title('Ground Track of Satellite over 24 Hours')
        plt.grid(True)
        plt.legend()
        plt.show()

        # üìà Elevation angle plot
        if all_pass_times:
            best_start, best_end = max(all_pass_times, key=lambda x: (x[1] - x[0]).total_seconds())
            elev_angles = []
            elev_times = []

            for r_vec, t in zip(pos, times):
                if best_start <= t <= best_end:
                    lat, lon = eci_to_latlon(r_vec)
                    sat_alt = np.linalg.norm(r_vec) - R_EARTH
                    elevation = compute_elevation(lat, lon, TARGET_LAT, TARGET_LON, sat_alt)

                    if elevation >= MIN_ELEVATION:
                        elev_angles.append(np.degrees(elevation))
                        elev_times.append(t)

            if elev_angles:
                plt.figure(figsize=(10, 4))
                plt.plot(elev_times, elev_angles, label='Elevation Angle')
                plt.axhline(np.degrees(MIN_ELEVATION), color='green', linestyle='--', label='Elevation Threshold')
                plt.xlabel("UTC Time")
                plt.ylabel("Elevation Angle (deg)")
                plt.title("Elevation Angle over Best Visibility Pass (Above Threshold)")
                plt.grid(True)
                plt.legend()
                plt.show()

    max_pass = max(pass_durations, default=0)
    total_visible = sum(pass_durations)
    num_passes = len(pass_durations)
    return max_pass, total_visible, num_passes


def sweep_altitudes():
    alts = np.arange(660e3, 689e3 + 1, 5e3)
    best_alt = None
    best_duration = 0
    for alt in alts:
        a = R_EARTH + alt
        e = 0.001
        inc = inclination_for_sso(a)
        RAAN, AOP, M0 = 0.0, 0.0, 0.0
        pass_durs = find_passes(a, e, inc, RAAN, AOP, M0, plot=False)
        max_pass = max(pass_durs, default=0)
        if max_pass > best_duration:
            best_duration = max_pass
            best_alt = alt

    if best_alt:
        print(f"‚úÖ Best Altitude: {best_alt / 1e3:.1f} km")
        print(f"üïì Longest Pass Duration: {best_duration:.1f} seconds")
        print(f"üì° Visibility Elevation Threshold: {np.degrees(MIN_ELEVATION):.1f}¬∞")

        # Re-run with best altitude for visualization
        a = R_EARTH + best_alt
        e = 0.001
        inc = inclination_for_sso(a)
        find_passes(a, e, inc, 0.0, 0.0, 0.0, plot=True)
    # ‚úÖ Return values here
        return best_alt, best_duration

    else:
        print("‚ùå No valid altitude found with visible passes.")
        return None, 0  # Optional: handles case where nothing was found


--------------------------------------------------------------------------------------------
# üõ∞Ô∏è NSSO Visibility Optimizer: Sweep Mean Anomaly (M0) for Best Pass Over ICN

def run_nsso_case(altitude_km, inc_deg, RAAN_deg, AOP_deg, plot=True):
    """
    Runs a single NSSO case with fixed altitude, inclination, RAAN, and AOP.
    Sweeps M0 to find best visibility duration over ICN.

    Parameters:
        altitude_km (float): Orbital altitude in kilometers
        inc_deg (float): Inclination in degrees
        RAAN_deg (float): Right Ascension of Ascending Node in degrees
        AOP_deg (float): Argument of Perigee in degrees
        plot (bool): Whether to plot the best pass visibility

    Returns:
        dict: A dictionary with the best M0, duration, and input parameters
    """
    a = R_EARTH + altitude_km * 1e3
    e = 0.001
    inc = np.radians(inc_deg)
    RAAN = np.radians(RAAN_deg)
    AOP = np.radians(AOP_deg)

    best_M0 = 0
    best_duration = 0
    best_total_visible = 0
    best_num_passes = 0

    for M0_deg in range(0, 360, 10):  # You can reduce step for finer sweep
        M0 = np.radians(M0_deg)
        max_pass, total_visible, num_passes = find_passes(a, e, inc, RAAN, AOP, M0, plot=False)

        if max_pass > best_duration:
            best_duration = max_pass
            best_total_visible = total_visible
            best_num_passes = num_passes
            best_M0 = M0


    print("üîç NSSO Configuration")
    print(f"    Altitude      : {altitude_km:.1f} km")
    print(f"    Inclination   : {inc_deg:.2f}¬∞")
    print(f"    RAAN          : {RAAN_deg:.1f}¬∞")
    print(f"    AOP           : {AOP_deg:.1f}¬∞")
    print(f"‚úÖ  Best M0        : {np.degrees(best_M0):.1f}¬∞")
    print(f"‚è±Ô∏è  Best Duration  : {best_duration:.1f} seconds")

    if plot:
        find_passes(a, e, inc, RAAN, AOP, best_M0, plot=True)

    return {
    "altitude_km": altitude_km,
    "inclination_deg": inc_deg,
    "RAAN_deg": RAAN_deg,
    "AOP_deg": AOP_deg,
    "best_M0_deg": round(np.degrees(best_M0), 1),
    "max_pass_duration_s": round(best_duration, 1),
    "total_visible_duration_s": round(best_total_visible, 1),
    "num_passes": best_num_passes
}

--------------------------------------------------------------------------------------------
# üîÑ High-Inclination NSSO Sweep: RAAN/AOP Grid Search for Optimal Visibility

nsso_results_high = []

inclinations_high = [93, 95, 97, 99, 100]
RAANs = list(range(0, 360, 60))
AOPs = [0, 90, 180, 270]

for inc_deg in inclinations_high:
    for RAAN_deg in RAANs:
        for AOP_deg in AOPs:
            result = run_nsso_case(
                altitude_km=685,
                inc_deg=inc_deg,
                RAAN_deg=RAAN_deg,
                AOP_deg=AOP_deg,
                plot=False
            )
            nsso_results_high.append(result)

------------------------------------------------------------------------------------
import pandas as pd

pd.DataFrame(nsso_results_high).to_csv("nsso_high_results.csv", index=False)

------------------------------------------------------------------------------------
# üîÑ Low-Mid Inclination NSSO Sweep: RAAN/AOP Grid Search for Optimal Visibility

nsso_results_low_mid = []

inclinations_low_mid = list(range(55, 90, 5))
RAANs = list(range(0, 360, 60))
AOPs = [0, 90, 180, 270]

for inc_deg in inclinations_low_mid:
    for RAAN_deg in RAANs:
        for AOP_deg in AOPs:
            result = run_nsso_case(
                altitude_km=685,
                inc_deg=inc_deg,
                RAAN_deg=RAAN_deg,
                AOP_deg=AOP_deg,
                plot=False
            )
            nsso_results_low_mid.append(result)

pd.DataFrame(nsso_results_low_mid).to_csv("nsso_low_mid_results.csv", index=False)

---------------------------------------------------------------------------------------
import pandas as pd

df_high = pd.read_csv("nsso_high_results.csv")
nsso_results_high = df_high.to_dict(orient="records")

----------------------------------------------------------------------------------------
print("‚úÖ Recovered entries:", len(nsso_results_high))
print("üîç Sample:", nsso_results_high[0])

----------------------------------------------------------------------------------------
top5_high = sorted(nsso_results_high, key=lambda x: x["max_pass_duration_s"], reverse=True)[:5]

print("üîù Top 5 NSSO Orbits ‚Äî High-Inclination")
for i, r in enumerate(top5_high, 1):
    print(f"{i}. Inc={r['inclination_deg']}¬∞, RAAN={r['RAAN_deg']}¬∞, AOP={r['AOP_deg']}¬∞ | "
          f"Max Pass={r['max_pass_duration_s']}s | Passes={r['num_passes']} | "
          f"Total Visible={r['total_visible_duration_s']}s")

-------------------------------------------------------------------------------------------
import pandas as pd
df_low = pd.read_csv("nsso_low_mid_results.csv")
nsso_results_low_mid = df_low.to_dict(orient="records")

--------------------------------------------------------------------------------------------
top5_lowmid = sorted(nsso_results_low_mid, key=lambda x: x["max_pass_duration_s"], reverse=True)[:5]

print("üîù Top 5 NSSO Orbits ‚Äî Low‚ÄìMid-Inclination")
for i, r in enumerate(top5_lowmid, 1):
    print(f"{i}. Inc={r['inclination_deg']}¬∞, RAAN={r['RAAN_deg']}¬∞, AOP={r['AOP_deg']}¬∞ | "
          f"Max Pass={r['max_pass_duration_s']}s | Passes={r['num_passes']} | "
          f"Total Visible={r['total_visible_duration_s']}s")

--------------------------------------------------------------------------------------------
# Define altitude sweep for a fixed inclination, RAAN, AOP
def sweep_altitude_for_nsso(inc_deg, RAAN_deg, AOP_deg, alt_range_km, plot=False):
    results = []
    for alt_km in alt_range_km:
        result = run_nsso_case(
            altitude_km=alt_km,
            inc_deg=inc_deg,
            RAAN_deg=RAAN_deg,
            AOP_deg=AOP_deg,
            plot=plot
        )
        results.append(result)
    return results

---------------------------------------------------------------------------------------------
# Define top 6 NSSO configurations for tuning
top_nsso_configs = [
    {"inc": 93, "RAAN": 60, "AOP": 180},
    {"inc": 93, "RAAN": 60, "AOP": 0},
    {"inc": 93, "RAAN": 0,  "AOP": 180},
    {"inc": 55, "RAAN": 0,  "AOP": 180},
    {"inc": 55, "RAAN": 300,"AOP": 180},
    {"inc": 55, "RAAN": 60, "AOP": 0},
]

# Altitude range: 670 to 690 km in 5 km steps
alt_range_km = list(range(670, 695, 5))

# Run the full sweep
nsso_fine_tuned_results = []

for cfg in top_nsso_configs:
    print(f"üõ∞Ô∏è Sweeping altitudes for: Inc={cfg['inc']}¬∞, RAAN={cfg['RAAN']}¬∞, AOP={cfg['AOP']}¬∞")
    sweep = sweep_altitude_for_nsso(cfg['inc'], cfg['RAAN'], cfg['AOP'], alt_range_km, plot=False)
    nsso_fine_tuned_results.extend(sweep)

# Optional: save for later
import pandas as pd
pd.DataFrame(nsso_fine_tuned_results).to_csv("nsso_fine_tuned_results.csv", index=False)

----------------------------------------------------------------------------------------------------
import pandas as pd

df = pd.read_csv("nsso_fine_tuned_results.csv")
print(f"‚úÖ Entries loaded: {len(df)}")
df.head()

----------------------------------------------------------------
df_high = pd.read_csv("nsso_high_results.csv")
df_lowmid = pd.read_csv("nsso_low_mid_results.csv")

# Combine and filter for only 685 km entries
df_all = pd.concat([df_high, df_lowmid])
df_685 = df_all[df_all["altitude_km"] == 685]

----------------------------------------------------------------------------------------------
top3_max_pass = df_685.sort_values("max_pass_duration_s", ascending=False).head(3)
top3_total_visible = df_685.sort_values("total_visible_duration_s", ascending=False).head(3)
top3_num_passes = df_685.sort_values("num_passes", ascending=False).head(3)

----------------------------------------------------------------------------------------------
def print_final_nssos(label, df_subset):
    print(f"\nüîù Top 3 NSSO ‚Äî {label}")
    for i, row in df_subset.iterrows():
        print(f"{i+1}. Inc={row['inclination_deg']}¬∞, RAAN={row['RAAN_deg']}¬∞, AOP={row['AOP_deg']}¬∞ | "
              f"Max={row['max_pass_duration_s']}s | Passes={row['num_passes']} | Total={row['total_visible_duration_s']}s")

print_final_nssos("By Max Pass Duration", top3_max_pass)
print_final_nssos("By Total Visibility", top3_total_visible)
print_final_nssos("By Number of Passes", top3_num_passes)

-----------------------------------------------------------------------------------------------
# Re-run selected NSSO cases and plot results
selected_nssos = [
    {"label": "Max1", "inc": 55.0, "RAAN": 300.0, "AOP": 180.0},
    {"label": "Max2", "inc": 75.0, "RAAN": 180.0, "AOP": 270.0},
    {"label": "Tot1", "inc": 55.0, "RAAN": 120.0, "AOP": 90.0},
    {"label": "Tot2", "inc": 55.0, "RAAN": 240.0, "AOP": 270.0},
]

from datetime import datetime
import csv

def save_nsso_result(result, label):
    filename = f"nsso_{label.lower()}_result.csv"
    with open(filename, mode='w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=result.keys())
        writer.writeheader()
        writer.writerow(result)
    print(f"üìÅ Saved: {filename}")

# Generate results and plots
for entry in selected_nssos:
    print(f"\nüîé Running NSSO: {entry['label']}")
    result = run_nsso_case(
        altitude_km=685,
        inc_deg=entry["inc"],
        RAAN_deg=entry["RAAN"],
        AOP_deg=entry["AOP"],
        plot=True
    )
    save_nsso_result(result, entry["label"])

--------------------------------------------------------------------
from datetime import datetime, timedelta

def convert_to_kst(utc_str):
    """
    Convert UTC time string to Korea Standard Time (UTC+9)
    """
    utc_time = datetime.strptime(utc_str, "%Y-%m-%d %H:%M:%S")
    kst_time = utc_time + timedelta(hours=9)
    return kst_time.strftime("%Y-%m-%d %H:%M:%S")

# Example UTC pass times (from your thesis data)
utc_passes = [
    "2025-03-20 03:52:30",
    "2025-03-20 14:53:20",
    "2025-03-20 13:32:20",
    "2025-03-20 20:27:10",
    "2025-03-20 22:10:20",
    "2025-03-20 04:18:50",
    "2025-03-20 14:37:10"
]

# Convert and display each local time
for utc in utc_passes:
    local = convert_to_kst(utc)
    print(f"UTC: {utc} ‚Üí KST: {local}")










